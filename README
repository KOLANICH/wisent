Wisent - a Parser Generator for Python


INTRODUCTION
============

   Wisent is an LR(1) parser generator for Python: it converts
context free grammars into Python code.

   Wisent comes with NO WARRANTY, to the extent permitted by law.
You may redistribute copies of Wisent under the terms of the GNU
General Public License.  For more information about these matters, read
the file COPYING of the source code distribution.

   Please email any suggestions and bug reports to Jochen Voss
<voss@seehuhn.de>.  Your message should include the Wisent version
number, as obtained by the command 'wisent -V'.

   The Wisent homepage can be found at http://seehuhn.de/pages/wisent .


INSTALLATION
============

   Generic installation instructions are in the file "INSTALL".  On
most systems, the following commands should be sufficient:

	./configure
	make
	make install

Alternatively you can omit the "make install" and run Wisent directly
in the build directory.


WISENT DOCUMENTATION
====================

   Wisent reads a grammar from a file and emits Python source code to
stdout.  The program is typically called as follows:

	wisent grammar.wi >parser.py

Wisent Grammar Files
--------------------

   Wisent grammar files, by convention the file names end in ".wi",
consist of a sequence of rules.  Each rule consists of a non-terminal
symbol, a colon ':', the expansion of the non-terminal given as a
sequence symbols followed by a semicolon ';'.  If a non-terminal has
several possible expansions, these can either be given on the right
hand side of one rule, separated by '|', or they can be written as
separate rules with identical left hand sides.

   On the right hand side you can write 'symbol *' as an abbreviation
for an arbitrary number of occurrences of 'symbol' and you can write
'symbol +' as an abbreviation for one or more occurrences of
'symbol'.  Symbols which contain non-alphanumeric characters should be
put in quotation marks.  The character '#' can be used for comments in
the grammar files: everything after a '#', until the next end of line,
is ignored.

   Wisent uses symbol names which start with an underscore character
'_' to denote "uninteresting" symbols.  These symbols are omitted from
the generated parse trees (see the more detailed description below).

   Every symbol which occurs on the left hand side of a rule is a
'non-terminal' symbol.  Every symbol which occurs in the expansion of
a rule and is not a non-terminal symbol is considered to be a
'terminal symbol'.  The non-terminal on the left hand side of the
first grammar rule is used as the 'start symbol'.

Example 1.  A grammar to describe the syntax of the Wisent input files
could look as follows.

	grammar: rule*;
	rule: TOKEN ":" rhs ";";
	rhs: list | rhs "|" list;
	list: item*;
	item: tos | tos "+" | tos "*";
	tos: TOKEN | STRING;

Conflicts
---------

   If the input grammar contains shift-reduce or reduce-reduce
conflicts, Wisent generates an example input string to illustrate the
problem in the error message.

Example 2.  Consider the following grammar file.

	ABC: a X Y c;
	X: b | ;
	Y: b | ;

In the language described by this grammar, for the input "a b c" the
symbol "b" could be either interpreted as "X" or as "Y".  The
corresponding Wisent error message is as follows.

	test.wi:2:4: shift-reduce conflict: the input
	test.wi:2:4:     'a'.'b' ...
	test.wi:2:4:   can be shifted using the production rule
	test.wi:2:4:     'X': .'b';
	test.wi:2:8:   or can be reduced to
	test.wi:2:8:     'a' 'X'.'b' ...
	test.wi:2:8:   using the production rule
	test.wi:2:8:     'X': ;
	test.wi: 1 conflict, aborting ...

   Conflicts should normally be resolved by rewriting the grammar to
make it unambiguous.  Since this is sometimes difficult or cumbersome,
Wisent provides an alternative mechanism to to select which one of the
conflicting actions the generated parser should choose.  These
conflict overrides are selected by placing additional exclamation
marks '!' in the grammar file: placing the exclamation mark before a
symbol (at the position given by the "can be shifted" part of the
error message) gives precedence to the shift action whereas placing
the exclamation mark at the end of the rule (at the position given by
the corresponding "can be reduced" message, just before the semicolon)
gives precedence to the reduce action.  In example 2 above we could
write "X: ! b | ;" to have the "b" interpreted as an "X" and we could
write "X: b | ! ;" to get "Y".


PARSER DOCUMENTATION
====================

   The output of Wisent is a complete Python source file, implementing
a single Python class 'Parser'.  The generated file can be used
stand-alone and has no dependency on Wisent any more.

   Assuming you wrote Wisent's output to the file "parser.py", you can
use the generated parser as illustrated by the following code sniplet:

	#! /usr/bin/env python

	from parser import Parser

	input = ...some iterable...

	p = Parser()
	try:
	    tree = p.parse(input)
	except p.ParseErrors, e:
	    # handle parse errors

	# now `tree` contains the parse tree

'Parser' objects have the following attributes:

    parse(input)
	A method to convert a given input into a parse tree.  See the
	description below.

    terminals
	A Python list, containing all terminal symbols of the grammar.

    leaves(tree)
	A generator to iterate over all leaves (corresponding to
	terminal symbols) of a parse tree.  See the description of
	parse trees below.

    ParseErrors
	A Python class, derived from 'Exception', used for error
	exceptions when reporting parse errors.

    EOF
	An object used internally to mark the end of input.  You might
	encounter this in data attached to a ParseErrors exception.

Parser Input
------------

   The input data to be parsed is given as the argument of the
'parse' method.  It must be an iterable, consisting of a sequence
of Python tuples and the first element of each tuple must be a
terminal symbol of the grammar.  All other elements of the input
tuples are copied into the output parse tree and are otherwise ignored
by the parser; you can use them to attach semantic values to the
symbols or to keep track of input line numbers for use in error
messages.

Example 3.  For a parser generated from the grammar given in example
1, the following Python sequence is a valid input:

    [ ( 'TOKEN', 'grammar' ),
      ( ':', ),
      ( 'TOKEN', 'rule' ),
      ( '*', ),
      ( ';', ) ]

This input could, for example, occur when the first rule of the above
grammar file is fed into the parser.

The Returned Parse Tree
-----------------------

   The 'parse' method of a 'Parser' object returns a parse tree, as a
collection of nested Python tuples.  A parse tree corresponding to a
terminal symbol equals the corresponding tuple from the input data.
These can be recognised by the fact that the first element of the
tuple is contained in the list 'terminals'.  All other trees
correspond to grammar rules: they have a non-terminal symbol as the
first element and the remaining elements are the parse trees for an
expansion of this non-terminal.  The first element of the tree
returned by 'parse' is always the start symbol of the grammar.

Example 4.  The input from example 3 leads to the following parse
tree:

	('grammar',
	    ('rule',
		('TOKEN', 'grammar'),
		(':',),
		('rhs',
		    ('list',
			('item',
			    ('tos',
				('TOKEN', 'rule')),
			    ('*',)))),
		(';',)))

   In real applications parse trees often become deeply nested,
because they contain many levels of "uninteresting" symbols like "rhs"
and "tos" in example 3.  To ease processing of the resulting trees,
Wisent generated parsers omit non-terminal whose names start with '_'.
Instead of a sub-tree rooted at the non-terminal the children of the
non-terminal are directly inserted into the containing tree.  This
reduces the local nesting level by one.

Example 5.  If we rename the non-terminals "rhs" to "_rhs", "tos" to
"_tos" and "item" to "_item" in examples 1 and 3, the parse tree
simplifies as follows:

	('grammar',
	    ('rule',
		('TOKEN', 'grammar'),
		(':',),
		('list',
		    ('TOKEN', 'rule'),
		    ('*',)),
		(';',)))

Parse Errors
------------

   When a parse error is encountered, Wisent tries to "repair" the
input in order to continue parsing so that as many parse errors as
possible can be found in one run.  Repairs are attempted by inserting,
deleting or changing a single token in a neighbourhood of the first
un-parseable token.

   All parse errors are returned simultaneously by raising a
ParseErrors exception.  The exception object has the following two
attributes:

    errors
	A list of tuples, each describing one error.  Each tuple
	consists of the first input token which could not be processed
	and the list of terminal symbols which were allowed at this
	point.  The list of allowed symbols might contain the special
	value 'EOF' to indicate that an end of input was allowed at
	this point.

    tree
	is a "repaired" parse tree which might be used for further
	error checking, or None if no repair was possible.


REFERENCES
==========

   The algorithm used in Wisent to generate the parser is based on the
following article:

    * David Pager, A practical general method for constructing LR(k) parsers.
      Acta Informatica, volume 7 (1977), number 3, pages 249
