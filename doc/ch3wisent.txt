.. _ch:wisent:

************************
Documentation for Wisent
************************

This chapter describes the Wisent parser generator itself.  The python
code generated by Wisent is described in the :ref:`following chapter
<ch:parser>`.


Describing the Format of your Input
===================================

Wisent grammar files are used to describe the format of the input your
program has to read.  By convention these files have names ending in
".wi".

A grammar file consist of a sequence of rules.  Each rule consists of
a non-terminal symbol, a colon ``:``, the expansion of the non-terminal
given as a sequence symbols followed by a semicolon ``;``.  If a
non-terminal has several possible expansions, these can either be
given on the right hand side of one rule, separated by ``|``, or they
can be written as separate rules with identical left hand sides.

On the right hand side you can write :samp:`{symbol} *` as an
abbreviation for an arbitrary number of occurrences of :samp:`symbol`
and you can write :samp:`{symbol} +` as an abbreviation for one or
more occurrences of :samp:`{symbol}`.  Symbols which contain
non-alphanumeric characters should be put in quotation marks.  The
character ``#`` can be used for comments in the grammar files:
everything after a ``#``, until the next end of line, is ignored.

Wisent uses symbol names which start with an underscore character
``_`` to denote "uninteresting" symbols.  These symbols are omitted from
the generated parse trees (see the more detailed description below).

Every symbol which occurs on the left hand side of a rule is a
'non-terminal' symbol.  Every symbol which occurs in the expansion of
a rule and is not a non-terminal symbol is considered to be a
'terminal symbol'.  The non-terminal on the left hand side of the
first grammar rule is used as the 'start symbol'.

**Example 1.**  A grammar to describe the syntax of Wisent input files
could look as follows::

    grammar: rule*;
    rule: TOKEN ":" rhs ";";
    rhs: list | rhs "|" list;
    list: item*;
    item: tos | tos "+" | tos "*";
    tos: TOKEN | STRING;

Conflicts
=========

If the input grammar contains shift-reduce or reduce-reduce
conflicts, Wisent generates an example input string to illustrate the
problem in the error message.

**Example 2.**  Consider the following grammar file::

    ABC: a X Y c;
    X: b | ;
    Y: b | ;

In the language described by this grammar, for the input "a b c" the
symbol "b" could be either interpreted as "X" or as "Y".  The
corresponding Wisent error message is as follows::

    test.wi:2:4: shift-reduce conflict: the input
    test.wi:2:4:     'a'.'b' ...
    test.wi:2:4:   can be shifted using the production rule
    test.wi:2:4:     'X': .'b';
    test.wi:2:8:   or can be reduced to
    test.wi:2:8:     'a' 'X'.'b' ...
    test.wi:2:8:   using the production rule
    test.wi:2:8:     'X': ;
    test.wi: 1 conflict, aborting ...

Conflicts should normally be resolved by rewriting the grammar to
make it unambiguous.  Since this is sometimes difficult or cumbersome,
Wisent provides an alternative mechanism to to select which one of the
conflicting actions the generated parser should choose.  These
conflict overrides are selected by placing additional exclamation
marks '!' in the grammar file: placing the exclamation mark before a
symbol (at the position given by the "can be shifted" part of the
error message) gives precedence to the shift action whereas placing
the exclamation mark at the end of the rule (at the position given by
the corresponding "can be reduced" message, just before the semicolon)
gives precedence to the reduce action.  In example 2 above we could
write "X: ! b | ;" to have the "b" interpreted as an "X" and we could
write "X: b | ! ;" to get "Y".



Running Wisent
==============

Wisent reads a grammar from a file and emits Python source code to
stdout.  The program is typically called as follows::

    wisent grammar.wi >parser.py

Command Line Options::

  -o NAME       store output in NAME instead of printing to stdout
  -e NAME       store example source code into NAME
  -h            show a help message
  -V            show version information
