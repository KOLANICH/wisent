.. _ch:tutorial:

********
Tutorial
********

This chapter gives a complete example of a project implemented using
the Wisent parser generator.  Here we will implement a simple
calculator.


.. index::
   single: grammar file

Creating The Grammar File
=========================

We create a file :download:`calculator.wi
<../examples/calculator/calculator.wi>` which contains the following
grammar.

.. literalinclude:: ../examples/calculator/calculator.wi

This file describes the structure of the input for our calculator.
The format of grammar files is describes in the section
:ref:`sec:grammar`.  The reason for the fact that some symbol names
are prefixed by ``_`` is explained in the section about
:ref:`sec:transparent`.


.. _sec:examplerun:

Running Wisent
==============

We use Wisent to generate a parser.  Execute the following command to
convert the grammar file :file:`calculator.wi` into python code::

    $ wisent -o parser.py -e calc.py calculator.wi

Detail about using the :command:`wisent` program are describe in the
section :ref:`sec:invocation`.  The program call generates a (long)
file :file:`parser.py` which contains the generated parser.  You can
use pythons introspection abilities, *e.g.* by calling :command:`pydoc
parser` on the command line.  The generated parser is described in
more detail in the section :ref:`sec:parser`.

.. index::
   single: print_tree()

The ``-e`` option instructs Wisent to generate example code in the
file :file:`calc.py`.  This code will not be useful in itself, but
it serves as an illustration of how to use the generated parser.
It looks as follows::

    from sys import stderr

    from parser import Parser

    def print_tree(tree, terminals, indent=0):
        """Print a parse tree to stdout."""
        prefix = "    "*indent
        if tree[0] in terminals:
            print prefix + repr(tree)
        else:
            print prefix + unicode(tree[0])
            for x in tree[1:]:
                print_tree(x, terminals, indent+1)

    input = [ ('NUMBER',), ('/',), ('SYMBOL',), ('(',), ('NUMBER',), ('*',),
              ('NUMBER',), ('+',), ('NUMBER',), ('/',), ('NUMBER',), (')',),
              ('*',), ('SYMBOL',), ('(',), ('NUMBER',), ('-',), ('NUMBER',),
              ('-',), ('NUMBER',), (')',) ]

    p = Parser()
    try:
        tree = p.parse(input)
    except p.ParseErrors, e:
        for token,expected in e.errors:
            if token[0] == p.EOF:
                print >>stderr, "unexpected end of file"
                continue

            found = repr(token[0])
            if len(expected) == 1:
                msg = "missing %s (found %s)"%(repr(expected[0]), found)
            else:
                msg1 = "parse error before %s, "%found
                l = sorted([ repr(s) for s in expected ])
                msg2 = "expected one of "+", ".join(l)
                msg = msg1+msg2
            print >>stderr, msg
        raise SystemExit(1)

    print_tree(tree, p.terminals)

The input of the generated parser (``input`` in the example code) must
be a sequence (or any iterable) of Python tuples where the first
element gives the type of input token.  It must be one of the terminal
symbols ``+``, ``-``, ``*``, ``/``, ``(``, ``)``, ``NUMBER``, and
``SYMBOL`` from the grammar.  The remaining elements of the tuples
(not present in the example code) don't affect the parsing process,
they are directly copied into the resulting output tree.  We will use
these elements to store the value of input numbers and function names.

The program just outputs the parse tree returned by ``p.parse``::

    expr
	difference
	    ('NUMBER',)
	    ('-',)
	    quotient
		function
		    ('SYMBOL',)
		    ('(',)
		    ('NUMBER',)
		    (')',)
		('/',)
		('NUMBER',)


.. _sec:tokenizer:

Adding a Tokenizer
==================

The next step is to edit the file :file:`calc.py` to add a tokenizer
which can convert a string typed by the user into a list of input
tokens for ``p.parse``:

.. literalinclude:: ../examples/calculator/calc.py
    :pyobject: tokenize

As required, this function breaks a string into a list of tokens::

    >>> tokenize("fn(1+2)")
    [('SYMBOL', fn'), ('(',), ('NUMBER', 1.0), ('+',), ('NUMBER', 2.0), (')',)]


Computing the Result from the Parse Tree
========================================

Write a function which recursively examines the parse tree and
computes the numerical result:

.. literalinclude:: ../examples/calculator/calc.py
    :pyobject: eval_tree

Details about the format of the parse tree are contained in the
section :ref:`sec:tree`.


Putting it all Together
=======================

The final result of our tutorial is the following python file
:download:`calculator.wi <../examples/calculator/calc.py>`:

.. literalinclude:: ../examples/calculator/calc.py

This file, together with the parser generated by Wisent, implements a
rudimentary calculator including some error handling::

    $ ./calc.py
    calc: 1
    1.0
    calc: 1*(2+3)
    5.0
    calc: 1+*2
    parse error before '*', expected one of '(', 'NUMBER', 'SYMBOL'
    calc: 4*sin(6)
    -1.1176619928

**Exercise:** This calculator can not yet deal with negative numbers::

    calc: -3
    parse error before '-', expected one of '(', 'NUMBER', 'SYMBOL'

Make the required changes to the code to fix this.
